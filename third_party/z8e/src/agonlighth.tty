; ___________________________________________________________________________
;|									     |
;|				  ADM3A.INC				     |
;|									     |
;|	Device-specific and hardware-dependent code for Z8E debugger.	     |
;|									     |
;| This file is intended to support one or two Lear-Siegler ADM3A or similar |
;| terminals, either real or virtual.					     |
;|									     |
;| Because the cursor positioning sequence is common to several terminals    |
;| including Wyse, Televideo and Soroc models it may be possible to match    |
;| use this file for other terminals.					     |
;|									     |
;| Some assembly-time conditionals are provided to help adapting this file   |
;| to different environments.						     |
;|___________________________________________________________________________|
;|									     |
;| There was a time when it was possible to patch the object code to support |
;| specific hardware.  That facility is no longer offered.  It is assumed    |
;| that anyone who is likely to be interested in using this program to debug |
;| software at the assembly language detail would have the means to write or |
;| adapt a module like this one and to rebuild the debugger from the source  |
;| code.								     |
;|___________________________________________________________________________|
;|									     |
;| This file is written to be as generic as possible and so should be easy   |
;| to adapt to different hardware.					     |
;|___________________________________________________________________________|


; This file is included twice when assembling.  The first time just loads
; the code, the second time defines the data associated with the code.

  if	defcode			; Load code

   ; ___________________________________________________________________ 
   ;|									|
   ;| Z8E imposes only one restriction on the code you write.  In order |
   ;| to guarantee that your routines can be relocated into high memory	|
   ;| by  Z8E  do not load any 16 bit  constants into  register  pairs;	|
   ;| instead  do  two  8  bit loads.  For  example,  do  not  use  the	|
   ;| following statement:						|
   ;|									|
   ;|			ld	de,1234h				|
   ;|									|
   ;| Rather, code it like this:					|
   ;|									|
   ;|			ld	d,12h					|
   ;|			ld	e,34h					|
   ;|									|
   ;| With  luck  you  won't  need to load a  constant  into  an  index	|
   ;| register  but if you do there are a few ways around the  problem. |
   ;| This one will work on a Z80 (but not on a Z180), does not depend  |
   ;| on the assembler chosen and does not touch any other register:	|
   ;|									|
   ;| Instead of:    ld      ix,5678h           ld      iy,5678h	|
   ;|									|
   ;| code:	     defb    0DDh		defb    0FDh		|
   ;|		     ld      h,56h		ld      h,56h		|
   ;|		     defb    0DDh		defb    0FDh		|
   ;|		     ld      l,78h		ld      l,78h		|
   ;|___________________________________________________________________|

    if terminal eq console
      if conterm eq agonlighth

;;===========================================================================
;; mttyq:
;;		     Main console input status routine
;;
;; This a conditional input routine, i.e. a non-blocking read.  If a console
;; key has been pressed then it returns the character generated by that key
;; otherwise it returns 0.
;;===========================================================================
	export	mttyq
;mttyq:
	ld	c,11			; Console input status
	call	bdos
	and	a			; Is a character available?
	ret	z			; Return zero if nothing there
					; Othersise fall through to input
					; routine

;;===========================================================================
;; mttyi:
;;		    Main physical keyboard input routine
;;		      (Default is CP/M console device)
;;===========================================================================
	export	mttyi
;mttyi:
	ld	c,6
	
    if	CPM3
	ld	e,0FDh			; CP/M+ interpretation of E register:
					; FF -> return 0 if nothing available
					;    -> otherwise the character
					; FE -> return 0 if nothing available
					;    -> return FF if there is something
					;	(in which case a 2nd call is
					;	needed to fetch the character).
					; FD -> Block until character is ready
					;	then return it.
    else				;
	ld	e,0FFh			; CP/M 2 doesn't assign special meaning
    endif				; to E=FE or FD.

	call	bdos			; Fetch character
	and	7FH			; Mask off high bit
	jr	z,mttyi			; Loop if no character or a NUL
	ret

;;===========================================================================
;; mttyo:
;;		    Main physical console output routine
;;		      (Default is CP/M console device)
;;===========================================================================

	export	mttyo
;mttyo:
	ld	e,a
	ld	c,6
	call	bdos
	ret

;;===========================================================================
;; mxycp:
;;		Main console screen cursor positioning routine
;;
;; Uses MXYSTR, MROWB4, MROW and MCOL for configuration.
;;
;; The version supplied here is for an ADM3A or similar terminal.
;;
;; This routine places the cursor at the row in B and the column in C.
;; Position (0,0) is the top left corner of the screen.
;;
;; If Z8E is being assembled to use two terminals and those two terminals
;; have very similar characteristics then the code herein may also be used
;; as the auxiliary screen cursor positioning routine.
;;===========================================================================

	export	mxycp
;mxycp:
        push    bc
        ld      a,31
        call    ttyo
        pop     bc
        push    bc
        ld      a,c
        call    ttyo
        pop     bc
        ld      a,b
        call    ttyo
        ret

;;===========================================================================
;; mcls:
;;		Main console screen clearing routine
;;
;; Uses MCLSTR for configuration.
;;
;; The version supplied here is for an ADM3A or similar terminal.
;;
;; If Z8E is being assembled to use two terminals and those two terminals
;; have very similar characteristics then the code herein may also be used
;; as the auxiliary screen cursor positioning routine.
;;===========================================================================

	export	mcls
;mcls:
        ld      a,12
        call    ttyo
        ret

      endif	; conterm = agonlighth
    endif	; terminal = console

  endif		; defcode

  if	defdata
;######################################################################
;# Second round inclusion ... define data areas for code shown above. #
;######################################################################

; The code portions are loaded by including this file twice, once for
; each terminal.  The data portions are handled in a single inclusion.

; Console ...

    if conterm eq agonlighth    ; then we definitely need these

    endif ; conterm = agonlighth

  endif ;defdata

; vim: ts=8 sw=8 et filetype=asm

