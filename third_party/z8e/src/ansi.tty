	.sall
; ___________________________________________________________________________
;|									     |
;|				  ANSI.TTY				     |
;|									     |
;|	Device-specific and hardware-dependent code for Z8E debugger.	     |
;|									     |
;| This file is intended to support one or two ANSI terminals, either real   |
;| or virtual.  Candidates would include DEC VT100 and similar, along with   |
;| most xterm implementations.						     |
;|									     |
;| Some assembly-time conditionals are provided to help adapting this file   |
;| to different environments.						     |
;|___________________________________________________________________________|
;|									     |
;| There was a time when it was possible to patch the object code to support |
;| specific hardware.  That facility is no longer offered.  It is assumed    |
;| that anyone who is likely to be interested in using this program to debug |
;| software at the assembly language detail would have the means to write or |
;| adapt a module like this one and to rebuild the debugger from the source  |
;| code.								     |
;|___________________________________________________________________________|
;|									     |
;| This file is written to be as generic as possible and so should be easy   |
;| to adapt to different hardware.					     |
;|___________________________________________________________________________|

; This file is included twice when assembling.  The first time just loads
; the code, the second time defines the data associated with the code.

	.lall
  if	defcode		; Load code

	.sall
   ; ___________________________________________________________________ 
   ;|									|
   ;| Z8E imposes only one restriction on the code you write.  In order |
   ;| to guarantee that your routines can be relocated into high memory	|
   ;| by  Z8E  do not load any 16 bit  constants into  register  pairs;	|
   ;| instead  do  two  8  bit loads.  For  example,  do  not  use  the	|
   ;| following statement:						|
   ;|									|
   ;|			ld	de,1234h				|
   ;|									|
   ;| Rather, code it like this:					|
   ;|									|
   ;|			ld	d,12h					|
   ;|			ld	e,34h					|
   ;|									|
   ;| With  luck  you  won't  need to load a  constant  into  an  index	|
   ;| register  but if you do there are a few ways around the  problem. |
   ;| This one will work on a Z80 (but not on a Z180), does not depend  |
   ;| on the assembler chosen and does not touch any other register:	|
   ;|									|
   ;| Instead of:    ld      ix,5678h           ld      iy,5678h	|
   ;|									|
   ;| code:	     defb    0DDh		defb    0FDh		|
   ;|		     ld      h,56h		ld      h,56h		|
   ;|		     defb    0DDh		defb    0FDh		|
   ;|		     ld      l,78h		ld      l,78h		|
   ;|___________________________________________________________________|

	.xall
    if terminal eq console
      if conterm eq ansi		; then we need to load the physical
					; drivers for the console

;;===========================================================================
;; mttyq:
;;		     Main console input status routine
;;
;; This a conditional input routine, i.e. a non-blocking read.  If a console
;; key has been pressed then it returns the character generated by that key
;; otherwise it returns 0.
;;===========================================================================
	export	mttyq
;mttyq:
	ld	c,11			; Console input status
	call	bdos
	and	a			; Is a character available?
	ret	z			; Return zero if nothing there
					; Othersise fall through to input
					; routine

;;===========================================================================
;; mttyi:
;;		    Main physical keyboard input routine
;;		      (Default is CP/M console device)
;;===========================================================================
	export	mttyi
;mttyi:
	ld	c,6
	
    if	CPM3
	ld	e,0FDh			; CP/M+ interpretation of E register:
					; FF -> return 0 if nothing available
					;    -> otherwise the character
					; FE -> return 0 if nothing available
					;    -> return FF if there is something
					;	(in which case a 2nd call is
					;	needed to fetch the character).
					; FD -> Block until character is ready
					;	then return it.
    else				;
	ld	e,0FFh			; CP/M 2 doesn't assign special meaning
    endif				; to E=FE or FD.

	call	bdos			; Fetch character
	and	7FH			; Mask off high bit
	jr	z,mttyi			; Loop if no character or a NUL
	ret

;;===========================================================================
;; mttyo:
;;		    Main physical console output routine
;;		      (Default is CP/M console device)
;;===========================================================================

	export	mttyo
;mttyo:
	ld	c,6		; Character for transmission is already in E
	call	bdos
	ret

;;===========================================================================
;; mxycp:
;;		Main console screen cursor positioning routine
;;
;; The version supplied here is for an ANSI-type terminal such as a VT100.
;; It doesn't use the usual MXYSTR, MROWB4, MROW and MCOL for configuration.
;;
;; This routine places the cursor at the row in B and the column in C.
;; Position (0,0) is the top left corner of the screen.
;;
;; If Z8E is being assembled to use two terminals and those two terminals
;; have very similar characteristics then the code herein may also be used
;; as the auxiliary screen cursor positioning routine.
;;===========================================================================

	export	mxycp
;mxycp:

;	ANSI screen driver - jrs - 27 May 87
;	Tested and corrected 29 Dec 88 - jrs

	inc	b		;Add 1 to row and column
	inc	c
	push	bc

	ld	a,1Bh		;Send ESC
	call	ttyo
	ld	a,'['		;Send [
	call	ttyo
	pop	bc		;Send row (Y) coordinate
	push	bc
	ld	a,b
	call	xycp00
	ld	a,';'		;Send ;
	call	ttyo
	pop	bc		;Send column (X) coordinate
	ld	a,c
	call	xycp00
	ld	a,'H'		;Send H
	call	ttyo
	ret

xycp00:
	ex	af,af'
	xor	a
	ex	af,af'
xycp10:
	ex	af,af'
	inc	a
	ex	af,af'
	sub	10
	jr	nc,xycp10
	ex	af,af'
	dec	a
	jr	z,xycp20
	add	a,'0'
	call	ttyo
xycp20:
	ex	af,af'
	add	a,'0'+10
	call	ttyo
	ret

;;===========================================================================
;; mcls:
;;		Main console screen clearing routine
;;
;; Uses MCLSTR for configuration.
;;
;; The version supplied here is for an ANSI-type terminal such as a VT100.
;;
;; If Z8E is being assembled to use two terminals and those two terminals
;; have very similar characteristics then the code herein may also be used
;; as the auxiliary screen cursor positioning routine.
;;===========================================================================

	export	mcls
;mcls:

	ld	hl,mclstr	; Screen clearing string
	ld	b,(hl)		; Get length of string
mcls0:
	inc	hl		; Step string pointer
	ld	a,(hl)		; Get character from screen clearing string
	call	ttyo		; Send character to terminal
	djnz	mcls0		; Count down and loop until all sent
	ret

      endif	; conterm = ansi
    endif	; terminal = console
      
;############################################################################
;# THE CODE FROM HERE ONWARDS ONLY EXISTS IF Z8E IS BEING ASSEMBLED TO USE  #
;# AN AUXILIARY TERMINAL FOR THE DEBUGGING DISPLAY, LEAVING THE CONSOLE FOR #
;# USE BY THE APPLICATION BEING MONITORED.				    #
;############################################################################

; Load these drivers if we need support for an auxiliary terminal.

  if auxterm eq ansi
    if	(terminal eq auxiliary)

;;===========================================================================
;; attyq:
;;	      Auxiliary physical keyboard input status routine.
;;
;; This only exists if Z8E is being assembled to support dual terminals.
;;
;; This is a conditional input routine - a non-blocking read.  It returns a
;; character from the auxiliary terminal if a key has been pressed, otherwise
;; it returns 0.
;;===========================================================================

	export	attyq
;attyq:

; If only the main console is active then use that.

	ld	a,(auxon)		; Is auxiliary terminal active?
	or	a
	jr	z,mttyq			; No - check console status instead

; Auxiliary terminal is in use ...

	; For CP/M+ the auxiliary input status is available as a BDOS call.

    if	CPM3

	ld	c,7			; Auxiliary input status
	call	bdos
	or	a			; Is a character available?
	ret	z			; No:  return a zero
					; Yes: fall through to input routine
    else

	; Not CP/M+.  Insert code to read a port here.
	; Example for SB180's serial port 0:

	xor	a			; Force address lines A8-A15 low
	ld	b,a
	in	a,(4)			; Read serial port status register
	and	80h			; Isolate high bit
	ret	z			; Return zero if nothing there
					; Fall through to input routine
    endif

;;===========================================================================
;; attyi:
;;		Auxiliary physical keyboard input routine
;;		  (Default is CP/M reader input device)
;;===========================================================================

	export	attyi
;attyi:
	ld	a,(auxon)		; Is 2nd terminal active?
	or	a
	jr	z,mttyi			; No, use console

	ld	c,3			; Auxiliary input (blocking)
	call	bdos

	and	7Fh			; Mask off the high bit
	jr	z,attyi			; Ignore a NUL character
	ret

;;===========================================================================
;; attyo:
;;		 Auxiliary physical console output routine
;;		   (Default is CP/M punch output device)
;;===========================================================================
	export	attyo
;attyo:
					; Character for transmission is
					; already in E
	ld	c,4			; AUX/PUN output
	call	bdos
	ret

;;===========================================================================
;; axycp:
;;		Auxiliary terminal cursor positioning routine
;;
;; The version supplied here is for an ANSI-type terminal such as a VT100.
;; It doesn't use the usual AXYSTR, AROWB4, AROW and ACOL for configuration.
;;
;; This routine places the cursor at the row in B and the column in C.
;; Position (0,0) is the top left corner of the screen.
;;===========================================================================

; This driver is only needed if the console and auxiliary terminals are
; different types.  If they are the same then Z8E can use the console driver
; to position the cursor on the auxiliary screen.

	if auxterm ne conterm

	export	axycp
;axycp:

;	ANSI screen driver - jrs - 27 May 87
;	Tested and corrected 29 Dec 88 - jrs

	inc	b		;Add 1 to row and column
	inc	c
	push	bc

	ld	a,1Bh		;Send ESC
	call	ttyo
	ld	a,'['		;Send [
	call	ttyo
	pop	bc		;Send row (Y) coordinate
	push	bc
	ld	a,b
	call	xycp00
	ld	a,';'		;Send ;
	call	ttyo
	pop	bc		;Send column (X) coordinate
	ld	a,c
	call	xycp00
	ld	a,'H'		;Send H
	call	ttyo
	ret

xycp00:
	ex	af,af'
	xor	a
	ex	af,af'
xycp10:
	ex	af,af'
	inc	a
	ex	af,af'
	sub	10
	jr	nc,xycp10
	ex	af,af'
	dec	a
	jr	z,xycp20
	add	a,'0'
	call	ttyo
xycp20:
	ex	af,af'
	add	a,'0'+10
	call	ttyo
	ret

;;===========================================================================
;; acls:
;;		Auxiliary terminal screen clearing routine
;;
;; Uses ACLSTR for configuration.
;;
;; The version supplied here is for an ANSI-type terminal such as a VT100.
;;===========================================================================

	export	acls
;acls:

	ld	hl,aclstr	; Screen clearing string
	ld	b,(hl)		; Get length of string
acls0:
	inc	hl		; Step string pointer
	ld	a,(hl)		; Get character from screen clearing string
	call	ttyo		; Send character to terminal
	djnz	acls0		; Count down and loop until all sent
	ret

	endif	; conterm ne auxterm
      endif	; terminal ne auxiliary
    endif	; auxterm ne ansi
  endif		; defcode

  if	defdata
;######################################################################
;# Second round inclusion ... define data areas for code shown above. #
;######################################################################

; The code portions are loaded by including this file twice, once for
; each terminal.  The data portions are handled in a single inclusion.

; Console ...

    if terminal eq console
      if conterm eq ansi	; then we definitely need these

	export	mclstr
;mclstr:
	defb	4,esc,'[2J'	; ANSI screen clearing

      endif ; conterm = ansi
    endif ; terminal eq console

; Auxiliary ...

    if auxterm eq ansi

; The following string is only needed if the console and auxiliary terminals
; are different types

      if auxterm ne conterm

	export	aclstr
;aclstr:
	defb	4,esc,'[2J'	; ANSI screen clearing

      endif ; auxterm ne conterm
    endif ; auxterm eq ansi

  endif	;defdata
