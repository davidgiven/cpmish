; ___________________________________________________________________________
;|									     |
;|				  ADM3A.INC				     |
;|									     |
;|	Device-specific and hardware-dependent code for Z8E debugger.	     |
;|									     |
;| This file is intended to support one or two Lear-Siegler ADM3A or similar |
;| terminals, either real or virtual.					     |
;|									     |
;| Because the cursor positioning sequence is common to several terminals    |
;| including Wyse, Televideo and Soroc models it may be possible to match    |
;| use this file for other terminals.					     |
;|									     |
;| Some assembly-time conditionals are provided to help adapting this file   |
;| to different environments.						     |
;|___________________________________________________________________________|
;|									     |
;| There was a time when it was possible to patch the object code to support |
;| specific hardware.  That facility is no longer offered.  It is assumed    |
;| that anyone who is likely to be interested in using this program to debug |
;| software at the assembly language detail would have the means to write or |
;| adapt a module like this one and to rebuild the debugger from the source  |
;| code.								     |
;|___________________________________________________________________________|
;|									     |
;| This file is written to be as generic as possible and so should be easy   |
;| to adapt to different hardware.					     |
;|___________________________________________________________________________|


; This file is included twice when assembling.  The first time just loads
; the code, the second time defines the data associated with the code.

  if	defcode			; Load code

   ; ___________________________________________________________________ 
   ;|									|
   ;| Z8E imposes only one restriction on the code you write.  In order |
   ;| to guarantee that your routines can be relocated into high memory	|
   ;| by  Z8E  do not load any 16 bit  constants into  register  pairs;	|
   ;| instead  do  two  8  bit loads.  For  example,  do  not  use  the	|
   ;| following statement:						|
   ;|									|
   ;|			ld	de,1234h				|
   ;|									|
   ;| Rather, code it like this:					|
   ;|									|
   ;|			ld	d,12h					|
   ;|			ld	e,34h					|
   ;|									|
   ;| With  luck  you  won't  need to load a  constant  into  an  index	|
   ;| register  but if you do there are a few ways around the  problem. |
   ;| This one will work on a Z80 (but not on a Z180), does not depend  |
   ;| on the assembler chosen and does not touch any other register:	|
   ;|									|
   ;| Instead of:    ld      ix,5678h           ld      iy,5678h	|
   ;|									|
   ;| code:	     defb    0DDh		defb    0FDh		|
   ;|		     ld      h,56h		ld      h,56h		|
   ;|		     defb    0DDh		defb    0FDh		|
   ;|		     ld      l,78h		ld      l,78h		|
   ;|___________________________________________________________________|

    if terminal eq console
      if conterm eq adm3a

;;===========================================================================
;; mttyq:
;;		     Main console input status routine
;;
;; This a conditional input routine, i.e. a non-blocking read.  If a console
;; key has been pressed then it returns the character generated by that key
;; otherwise it returns 0.
;;===========================================================================
	export	mttyq
;mttyq:
	ld	c,11			; Console input status
	call	bdos
	and	a			; Is a character available?
	ret	z			; Return zero if nothing there
					; Othersise fall through to input
					; routine

;;===========================================================================
;; mttyi:
;;		    Main physical keyboard input routine
;;		      (Default is CP/M console device)
;;===========================================================================
	export	mttyi
;mttyi:
	ld	c,6
	
    if	CPM3
	ld	e,0FDh			; CP/M+ interpretation of E register:
					; FF -> return 0 if nothing available
					;    -> otherwise the character
					; FE -> return 0 if nothing available
					;    -> return FF if there is something
					;	(in which case a 2nd call is
					;	needed to fetch the character).
					; FD -> Block until character is ready
					;	then return it.
    else				;
	ld	e,0FFh			; CP/M 2 doesn't assign special meaning
    endif				; to E=FE or FD.

	call	bdos			; Fetch character
	and	7FH			; Mask off high bit
	jr	z,mttyi			; Loop if no character or a NUL
	ret

;;===========================================================================
;; mttyo:
;;		    Main physical console output routine
;;		      (Default is CP/M console device)
;;===========================================================================

	export	mttyo
;mttyo:
	ld	e,a
	ld	c,6
	call	bdos
	ret

;;===========================================================================
;; mxycp:
;;		Main console screen cursor positioning routine
;;
;; Uses MXYSTR, MROWB4, MROW and MCOL for configuration.
;;
;; The version supplied here is for an ADM3A or similar terminal.
;;
;; This routine places the cursor at the row in B and the column in C.
;; Position (0,0) is the top left corner of the screen.
;;
;; If Z8E is being assembled to use two terminals and those two terminals
;; have very similar characteristics then the code herein may also be used
;; as the auxiliary screen cursor positioning routine.
;;===========================================================================

	export	mxycp
;mxycp:

	ld	hl,mxystr	; Cursor addressing string
	ld	a,(mrow)	; Get row bias
	add	a,b		; Add row
	ld	b,a		; Save row selector
	ld	a,(mcol)	; Get column bias
	add	a,c		; Add column
	ld	c,a		; Save column selector
	ld	e,(hl)		; Get length of cursor addressing string
mxy0:
	inc	hl		; Step string pointer
	ld	a,(hl)		; Get character from cursor addressing string
	call	ttyo		; Send character to terminal
	dec	e		; Count down
	jr	nz,mxy0		; Loop until all sent
	ld	a,(mrow4)	; Row first or column first?
	and	a
	jr	nz,mxy1		; Skip if row first
	ld	a,b		; x,y addressing, interchange row and column
	ld	b,c
	ld	c,a
mxy1:
	ld	a,b		; Send first coordinate
	call	ttyo
	ld	a,c		; Send second coordinate
	call	ttyo
	ret

;;===========================================================================
;; mcls:
;;		Main console screen clearing routine
;;
;; Uses MCLSTR for configuration.
;;
;; The version supplied here is for an ADM3A or similar terminal.
;;
;; If Z8E is being assembled to use two terminals and those two terminals
;; have very similar characteristics then the code herein may also be used
;; as the auxiliary screen cursor positioning routine.
;;===========================================================================

	export	mcls
;mcls:

	ld	hl,mclstr	; Screen clearing string
	ld	b,(hl)		; Get length of string
mcls0:
	inc	hl		; Step string pointer
	ld	a,(hl)		; Get character from screen clearing string
	call	ttyo		; Send character to terminal
	djnz	mcls0		; Count down and loop until all sent
	ret

      endif	; conterm = adm3a
    endif	; terminal = console

;############################################################################
;# THE CODE FROM HERE ONWARDS ONLY EXISTS IF Z8E IS BEING ASSEMBLED TO USE  #
;# AN AUXILIARY TERMINAL FOR THE DEBUGGING DISPLAY, LEAVING THE CONSOLE FOR #
;# USE BY THE APPLICATION BEING MONITORED.				    #
;############################################################################

; Load these drivers if we need support for an auxiliary terminal
    if	terminal eq auxiliary
      if auxterm eq adm3a

;;===========================================================================
;; attyq:
;;	      Auxiliary physical keyboard input status routine.
;;
;; This only exists if Z8E is being assembled to support dual terminals.
;;
;; This is a conditional input routine - a non-blocking read.  It returns a
;; character from the auxiliary terminal if a key has been pressed, otherwise
;; it returns 0.
;;===========================================================================

	export	attyq
;attyq:

; If only the main console is active then use that.

	ld	a,(auxon)		; Is auxiliary terminal active?
	or	a
	jr	z,mttyq			; No - check console status instead

; Auxiliary terminal is in use ...

	; For CP/M+ the auxiliary input status is available as a BDOS call.

    if	cpm3

	ld	c,7			; Auxiliary input status
	call	bdos
	or	a			; Is a character available?
	ret	z			; No:  return a zero
					; Yes: fall through to input routine
    else ;cpm3

	; Not CP/M+.  Insert code to read a port here.
	; Example for SB180's serial port 0:

	xor	a			; Force high address lines to zero
	ld	b,a
	in	a,(4)			; Read serial port status register
	and	80h			; Isolate high bit
	ret	z			; Return zero if nothing there
					; Fall through to input routine
    endif ;cpm3

;;===========================================================================
;; attyi:
;;		Auxiliary physical keyboard input routine
;;		  (Default is CP/M reader input device)
;;===========================================================================

	export	attyi
;attyi:
	ld	a,(auxon)		; Is 2nd terminal active?
	or	a
	jr	z,mttyi			; No, use console

	ld	c,3			; Auxiliary input (blocking)
	call	bdos

	and	7Fh			; Mask off the high bit
	jr	z,attyi			; Ignore a NUL character
	ret

;;===========================================================================
;; attyo:
;;		 Auxiliary physical console output routine
;;		   (Default is CP/M punch output device)
;;===========================================================================

	export	attyo
;attyo:
	ld	c,4			; AUX/PUN output
	call	bdos
	ret

;;===========================================================================
;; axycp:
;;		Auxiliary terminal cursor positioning routine
;;
;; Uses AXYSTR, AROWB4, AROW and ACOL for configuration.
;;
;; The version supplied here is for an ADM3A but may work for others such as
;; Wyse, Televideo or Soroc.
;;
;; This routine places the cursor at the row in B and the column in C.
;; Position (0,0) is the top left corner of the screen.
;;===========================================================================

; This driver is only needed if the console and auxiliary terminal are
; different types.  If they are the same then Z8E can use the console driver
; to position the cursor on the auxiliary screen.

	if	auxterm ne conterm

	export	axycp
;axycp:

	ld	hl,axystr	; Cursor addressing string
	ld	a,(arow)	; Get row bias
	add	a,b		; Add row
	ld	b,a		; Save row selector
	ld	a,(acol)	; Get column bias
	add	a,c		; Add column
	ld	c,a		; Save column selector
	ld	e,(hl)		; Get length of cursor addressing string
axy0:
	inc	hl		; Step string pointer
	ld	a,(hl)		; Get character from cursor addressing string
	call	ttyo		; Send character to terminal
	dec	e		; Count down
	jr	nz,axy0		; Loop until all sent
	ld	a,(arowb4)	; Row first or column first?
	and	a
	jr	nz,axy1		; Skip if row first
	ld	a,b		; x,y addressing, interchange row and column
	ld	b,c
	ld	c,a
axy1:
	ld	a,b		; Send first coordinate
	call	ttyo
	ld	a,c		; Send second coordinate
	call	ttyo
	ret

;;===========================================================================
;; acls:
;;		Auxiliary terminal screen clearing routine
;;
;; Uses ACLSTR for configuration.
;;
;; The version supplied here is for an ADM3A but may work for others such as
;; Wyse, Televideo or Soroc.
;;===========================================================================

	export	acls
;acls:

	ld	hl,aclstr	; Screen clearing string
	ld	b,(hl)		; Get length of string
acls0:
	inc	hl		; Step string pointer
	ld	a,(hl)		; Get character from screen clearing string
	call	ttyo		; Send character to terminal
	djnz	acls0		; Count down and loop until all sent
	ret

	endif	; auxterm ne conterm
      endif	; terminal ne adm3a
    endif	; terminal ne auxiliary
  endif		; defcode

  if	defdata
;######################################################################
;# Second round inclusion ... define data areas for code shown above. #
;######################################################################

; The code portions are loaded by including this file twice, once for
; each terminal.  The data portions are handled in a single inclusion.

; Console ...

    if conterm eq adm3a		; then we definitely need these

; Configuration bytes for main terminal - ADM3A (and similar)

	export	mrowb4
;mrowb4:
	defb	1		; ADM3A uses y,x addressing, i.e. row first.
				; This is the more common coordinate order.

	export	mrow
;mrow:
	defb	' '		; Bias for cursor row coordinates

	export	mcol
;mcol:
	defb	' '		; Same for column

	export	mxystr
;mxystr:
	defb	2,esc,'='	; ADM3A cursor positioning

	export	mclstr
;mclstr:
	defb	1,1Ah		; ADM3A screen clearing

    endif ; conterm = adm3a

; Auxiliary ...

    if auxterm eq adm3a

; Configuration bytes for auxiliary terminal - ADM3A and similar

	export	arowb4
;arowb4:
	defb	1		; ADM3A uses y,x addressing, i.e. row first.
				; This is the more common coordinate order.

	export	arow
;arow:
	defb	' '		; Bias for cursor row coordinates

	export	acol
;acol:
	defb	' '		; Same for column

; The lead-in string is only needed if the console and auxiliary terminals
; are different types

      if auxterm ne conterm

	export	axystr
;axystr:
	defb	2,esc,'='	; ADM3A cursor positioning

	export	aclstr
;aclstr:
	defb	1,1Ah		; ADM3A screen clearing

      endif ; auxterm ne conterm
    endif ; auxterm eq adm3a
  endif ;defdata
